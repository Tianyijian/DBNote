# 20. 数据库查询实现算法之两趟扫描算法
重点与难点

- 理解两趟算法的基本思想
- 理解两阶段多路归并排序算法，进一步理解基于排序的两趟扫描算法
- 理解散列算法的核心思想，进一步理解基于散列的两趟扫描算法
- 关系代数操作的两趟扫描算法实现

## 20.1 为什么需要两趟算法
- 需保存的待处理数据块数远远大于内存可用块数
- 基本思想：
	- 第一趟：划分子集，并使子集具有某种特性，如有序或相同散列值等
	- 第二趟：处理全局性内容的操作，形成结果关系。如多子集间的归并排序，相同散列值子集的操作等

## 20.2 两阶段多路归并排序算法
- 子集和数<M，子集合块数<M，即大数据集块数<M*M

## 20.3 基于排序的两趟扫描算法
- 基于排序的两趟算法的第一趟都是划分子表并排序。每一个子表应都能装入内存，并进行排序，然后再存回磁盘。
- 基于排序的两趟算法的第二趟是进行归并，在归并的过程中可以**边排序边去重复**，归并完成即去重复操作完成。
- 基于排序的两趟算法的第二趟是进行归并，在归并的过程中可以**一边排序一边进行分组并进行聚集计算**，归并完成即分组聚集计算操作完成。

## 20.4 基于散列的两趟扫描算法
- 去重复：
	- Hp = 计算元组部分属性的值 MOD M。
	- Hr = 计算整个元组的值 MOD M
- 分组：
	- Hp = 计算“分组属性”的值 MOD M。
	- Hr = 以“分组属性”的二进制位串重新计算值，然后 MOD M。
- 基于散列的两趟算法的第一趟是散列子表。用某一个散列函数，将具有相同散列值的元组散列到相同的子表中并存回磁盘。
- 基于散列的两趟算法的第二趟是用与第一趟不同的散列函数，将子表再散列到内存的不同内存块中，**在具有相同散列值的所有内存块中去重复**，即是在整个关系上去重复。所有子表处理完成，去重复操作即告完成。
- 关于R与S的并、交、差运算的基于散列的两趟算法，必须**用相同的散列函数**将R和S分别散列成若干个子表
- 第一趟散列的目的是**使数据子集具有某一种特性**(如具有相同的散列值)，而第二趟散列的目的是**提高数据处理的速度**。


## 20.5 习题
- 基于排序的算法总是可以**均匀地划分子表**(即每个子表的大小都一样，除最后一块外)；基于散列的算法**不能保证总是均匀地划分子表**
- 排序算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理（第二趟）；散列算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表（第二趟）
- 已知内存共有100块，若要排序有10000块的数据集，该数据集**不能在两趟内**实现排序，磁盘读写次数为40400次
- 已知关系R和S。关系占用的磁盘块数B(R)=1000，B(S)=1000，已知可用内存页数M=40，用**两趟算法不能实现**R和S的集合并操作