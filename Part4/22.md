# 22. 数据库事务处理技术之并发控制
重点与难点

- 理解数据库并发操作的三种不一致性及其产生原因
- 理解一组概念：事务、事务调度、可串行性、时间戳等
- 掌握三种类型的并发控制方法：基于封锁的方法、基于时间戳的方法、基于有效性确认的方法
- 重点掌握：冲突可串行性判别算法，两段封锁法，基于时间戳的方法

## 22.1 为什么需要并发控制
- 多应用程序可能同时使用一个数据库
- 三种典型的不一致现象：丢失修改、不能重复读、脏读

## 22.2 事务调度及可串行性
- 事务，事务的特性：原子性、一致性、隔离性、持久性，循环产生事务
- **并行调度的正确性**，**可串行化调度**，**冲突可串行性**
- 可串行化调度一定是正确的并行调度，但正确的并行调度，却未必都是可串行化的调度
- 满足冲突可串行性，一定满足可串行性；反之不然
- **冲突可串行性判别算法**：构造有向图
- w1(Y); w2(Y); w2(X); w1(X); w3(X);不是冲突可串行化调度，但却是可串行化调度，是正确的并行调度

## 22.3 基于封锁的并发控制方法
- 封锁协议需要考虑：封锁的类型、相容性矩阵、封锁的时机、封锁的粒度
- 两段封锁协议：
	- **读写数据之前要获得锁**。每个事务中所有封锁请求先于任何一个解锁请求
	- **加锁段中不能有解锁操作，解锁段中不能有加锁操作**
	- **写之前不能解锁**
	- 两段封锁协议是可以保证冲突可串行性的
	- 两段锁协议是可能产生“死锁”的协议
	- 两阶段封锁法是可串行化的并行调度算法，一定能保证数据更新的一致性
	
## 22.4 基于时间戳的并发控制方法
- 时间戳：时间戳是一种基于时间的标志，将某一时刻转换成的一个数值。时间戳具有唯一性和递增性
- 冲突类型：读-写或写-读冲突；写-写冲突。
- RT(x),WT(x),TS(T),**简单调度规则：解决过晚的读，过晚的写**
- 解决脏读，托马斯写规则，另一种调度规则：C(x)

## 22.5 基于有效性确认的并发控制方法
- 批量性的冲突检测
- 事务分三个阶段进行:读阶段、有效性确认阶段、写阶段
- 调度器维护三个集合：START、VAL、FIN 
- FIN(U)>START(T), 判断RS(T)交WS(U)；FIN(U)>VAL(T)，判断WS(T)交WS(U)

## 22.6 习题
- 每次循环过程可能会产生一个事务，也可能不产生，事务数**小于等于**循环次数
- 若要使事务的执行是可恢复的，则对有写有求的数据对象加排他锁后，须在**该事务提交时刻**解锁才能保证可恢复性。
- TS方法是比较事务的时间戳与数据库元素的时间戳来判断是否有冲突，而VA方法是通过比较两个事务的读写数据集合是否有交集来判断是否有冲突
- TS方法和VA方法都是以撤销事务并重启事务来解决事务之间的冲突
- TS方法和VA方法都是利用时间戳表征事务的启动时刻，表征事务的执行次序