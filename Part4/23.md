# 23. 数据库事务处理技术之故障恢复
重点与难点

- 理解三种类型的故障：事务故障、系统故障和介质故障
- 三种类型故障的恢复手段：运行日志和副本
- 理解检查点的作用
- 理解三种类型的运行日志及其故障恢复的操作方法：Undo型日志，Redo型日志，Undo/Redo型日志


## 23.1 数据库故障恢复的宏观思路
- **故障类型**
	- 事务故障：某一个程序(事务)自身运行错误所引起的故障。影响该程序(事务)本身。
	- 系统故障：由于掉电、非正常关机等所引起的故障。影响正在运行的事务以及数据库缓冲区, 数据库缓冲区将涉及正在运行和已经运行的事务
	- 介质故障：由于介质损坏等所引起的故障。影响是全面的，既影响内存中的数据, 又影响介质中存储的数据
- 故障恢复
	- 事务故障的恢复：重做事务(Redo)和撤消事务(Undo)
	- 系统故障恢复：运行日志(System Log)、检查点
	- 介质故障恢复：副本、转储点
- 检查点
	- 是DBMS强制使内存DB Buffer中的内容与介质DB中的内容保持一致的时刻点
	- 检查点之前结束的事务不需要恢复(已经写回DB)
	- 检查点之后结束或发生的事务需要依据运行日志进行恢复(不能确定是否写回DB): 故障点前结束的重做,故障点时刻未结束的撤消

## 23.2 运行日志及其检查点
- 日志文件是用于记录**对数据的所有更新操作**，便于故障时恢复，保证事务的原子性和持久性
- 缓冲区处理策略：
	- Force： 内存中的数据最晚在commit的时候写入磁盘。
	- No steal： 不允许在事务commit之前把内存中的数据写入磁盘。
	- No force： 内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘。(此时在系统崩溃的时候可能还没写入到磁盘，需要Redo)。--灵活
 	- Steal： 允许在事务commit之前把内存中的数据写入磁盘。(此时若系统在commit之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要Undo）。--灵活
 	- 效率较低但不会出现问题的策略组合是**No Steal+ Force**，而效率最高最常用但会出现问题的策略组合是**Steal + No Force**

## 23.3 三种类型的运行日志
- **Undo型日志**
	- 仅保留旧值
	- 用于解决：故障时，未提交事务已提前写入磁盘的问题
	- Undo型日志是先将数据写回磁盘OUTPUT，再将Commit记录写入日志
	- 用Undo型日志恢复是从日志的尾部开始恢复，按日志记录的反序处理，直至遇到第一个检查点为止结束
	- 用Undo型日志恢复是对已完成的事务，跳过；而对未完成的事务，将日志记录的值写回磁盘
- **Redo型日志**
	- 仅保留新值
	- 用于解决：故障时，已提交事务滞留内存未被写入磁盘的问题
	- Redo型日志是先将Commit记录写入日志，再将数据写回磁盘OUTPUT
	- 用Redo型日志恢复是从日志的尾部开始由后向前扫描直至遇到第一个检查点，然后自该检查点开始恢复，按日志正序处理，直至日志记录的尾部结束
	- 用Redo型日志恢复是对已完成的事务，将日志记录的值写回磁盘；而对未完成的事务，跳过
- Undo/Redo结合型日志
	- 既保留新值，也保留旧值
	- Redo型是先写提交记录后输出；undo型是先输出，再写提交记录；undo/redo无所谓谁先谁后，只要保证<T,X,u,v>被先于OUTPUT写完即可
	- 自后向前地撤销所有未提交的事务；自前向后地重做所有已提交的事务；

